% easychair.tex,v 3.5 2017/03/15

\documentclass{easychair}
%\documentclass[EPiC]{easychair}
%\documentclass[EPiCempty]{easychair}
%\documentclass[debug]{easychair}
%\documentclass[verbose]{easychair}
%\documentclass[notimes]{easychair}
%\documentclass[withtimes]{easychair}
%\documentclass[a4paper]{easychair}
%\documentclass[letterpaper]{easychair}

\usepackage{doc}
\usepackage{minted}

% use this if you have a long article and want to create an index
% \usepackage{makeidx}

% In order to save space or manage large tables or figures in a
% landcape-like text, you can use the rotating and pdflscape
% packages. Uncomment the desired from the below.
%
% \usepackage{rotating}
% \usepackage{pdflscape}

% Some of our commands for this guide.
%
\newcommand{\easychair}{\textsf{easychair}}
\newcommand{\miktex}{MiK{\TeX}}
\newcommand{\texniccenter}{{\TeX}nicCenter}
\newcommand{\makefile}{\texttt{Makefile}}
\newcommand{\latexeditor}{LEd}

%\makeindex

%% Front Matter
%%
% Regular title as in the article class.
%
\title{Meta-Reasoning in MeTTa for Inference Control via Provably
  Pruning the Search Tree}

% Authors are joined by \and. Their affiliations are given by \inst, which indexes
% into the list defined using \institute
%
\author{Nil Geisweiller}

% Institutes for affiliations are also joined by \and,
\institute{
  SingularityNET Foundation,\\
  Zug, Switzerland\\
  \email{nil@singularitynet.io}
}

%  \authorrunning{} has to be set for the shorter version of the authors' names;
% otherwise a warning will be rendered in the running heads. When processed by
% EasyChair, this command is mandatory: a document without \authorrunning
% will be rejected by EasyChair
\authorrunning{Geisweiller}

% \titlerunning{} has to be set to either the main title or its shorter
% version for the running heads. When processed by
% EasyChair, this command is mandatory: a document without \titlerunning
% will be rejected by EasyChair
\titlerunning{Meta Reasoning in MeTTa for Inference Control}

\begin{document}

\maketitle

\section{Methodology}
\label{sect:introduction}

How to speed-up reasoning by reasoning about reasoning?  This is the
question we will attempt to begin to answer in the context of a
meta-reasoning experiment described below.
\begin{enumerate}
\item A backward chainer is implemented in MeTTa~\cite{TODO} that
  takes in input a \emph{problem} theory (a set of rewriting rules), a
  query (a typing relationship with holes) and outputs the query with
  its holes filled.  By leveraging MeTTa non-determinism and
  unification built-in features, a very compact implementation can be
  obtained, as evidenced by the code in
  Appendix~\ref{app:metta-backward-chainer}.
\item The backward chainer is then modified by inserting conditionals
  at every non-deterministic intersection.  These conditionals are
  there to decide whether to prune or to continue a particular path of
  the backward chainer.  The modified base case of the backward
  chainer is given in
  Appendix~\ref{app:backward-chainer-continuation-conditionals}.  The
  modified recursive step is omitted for sake of conciseness but can
  be found in~\cite{TODO}.
\item The \emph{continuation} predicates associated to these
  conditionals are themselves defined as backward chainer calls over a
  \emph{control} theory, alongside a query formulating the question of
  whether to prune or to continue a particular branch.  Thus, at every
  step during problem solving, the backward chainer over the control
  theory is called.  If a proof of continuation is found, then the
  backward chainer over the problem theory is allowed to pursue its
  particular path, otherwise the branch is pruned.
\end{enumerate}

\section{Results}

The experiment is carried over a toy problem, the relationship of
precedence between the months of the year with a shortcut for the
month of January.  The control theory is simple and tailored toward
that particular problem only, by formalizing the January shortcut.
Performances with and without inference control are compared.  In that
experiment the simplicity of the control theory allows to obtain
proofs of continuation with little to no cost.  For that reason, the
performances with inference control are dramatically improved, ranging
from no speed-up to many-fold speed-ups depending on the difficulty of
the query.  Thus, as simplistic as it may be, the use of reasoning to
speed-up reasoning is demonstrated.  More information about the
experiment alongside its code can be found in~\cite{TODO}.

%% This is the question we will begin to attempt answer in that paper.

%% Ways to inference control:
%% 1. Learn the continuation/termination predicate (classifier)
%% 2. Introspective reasoning
%% 2.1. Terminate/Continue type
%% 2.2. Cognitive schematics


%% By combining unification and non-determinism, MeTTa allows us to
%% implement in just a few lines of code a generic program and type
%% synthesizer capable of
%% 1. Synthesizing a program (or a proof) given its specification
%% 2. Infer the type of a program (or a proof)
%% 3. Partially fills holes in a program/proof or its type.

%% Non-determinism is a placeholder for any inference control policy.

\section{Related and Future Work}

The following paper~\cite{} contains a great overview of the field of
meta-reasoning, which nonetheless is still vastly under-explored.

That work is only scratching the surface.  Below are a few suggestions
for further improvements and exploration.
\begin{enumerate}
\item The control theory should broadly capture the notion of
  inference control and efficiency, as opposed to being hardwired to a
  specific problem.  This would allow to reuse such control theory
  over many problems.
\item The control theory should be amenable to reason about empirical
  data.  In this manner, traces left by the backward chainer while
  attempting to solve problems could be used to infer predictive
  patterns about the likelihood of success of pursuing a particular
  path.  This could be done via pattern mining, abstract reasoning, or
  combinations thereof~\cite{TODO}.
\item The control theory should be so broad and applicable that it may
  benefit inference control of the control theory itself.  This would
  open the possibility of creating a virtuous feedback loop of
  meta-reasoning.
\end{enumerate}
%% What about reasoning about learning, from its most generic forms, such
%% as Solomonoff Induction~\cite{TODO}, to its most specialized forms,
%% such as XXX~\cite{TODO}?

%% Create a virtuous feedback loop

%------------------------------------------------------------------------------

\bibliographystyle{plain}
\label{sect:bib}
%\bibliographystyle{alpha}
%\bibliographystyle{unsrt}
%\bibliographystyle{abbrv}
\bibliography{easychair}

%------------------------------------------------------------------------------
\appendix
\section{MeTTa Backward Chainer}
\label{app:metta-backward-chainer}

The backward chainer, \texttt{bc}, takes three arguments, a knowledge
base containing the theory \texttt{\$kb}, a query containing a typing
relationship between proof and theorem \texttt{(: \$prf \$thrm)}, and
a maximum depth.  It returns a non-deterministic superposition of
results, the query with its variables substituted by MeTTa terms
encoding wholes or parts of proofs and theorems.  It has two cases
\begin{enumerate}
\item Base case: the query directly matches an element of the
  knowledge base.
\item Recursive step: the query is divided into two sub-queries, one
  for finding a proof abstraction and another one for finding a proof
  argument applied to that proof abstraction.
\end{enumerate}
Unlike with traditional recursive algorithms, the base case and the
recursive step are non-deterministically competing with each other.
Also, in MeTTa the \texttt{let} operation corresponds to unification.
The code is provided below and more information can be found
here~\cite{TODO} \small{
\begin{minted}{scheme}
;; Base case
(= (bc $kb (: $prf $thrm) $_) (match $kb (: $prf $thrm) (: $prf $thrm)))
;; Recursive step
(= (bc $kb (: ($prfabs $prfarg) $thrm) (S $k))
   (let* (((: $prfabs (-> $prms $thrm)) (bc $kb (: $prfabs (-> $prms $thrm)) $k))
          ((: $prfarg $prms) (bc $kb (: $prfarg $prms) $k)))
     (: ($prfabs $prfarg) $thrm)))
\end{minted}
}

\section{Backward Chainer with Continuation Conditionals}
\label{app:backward-chainer-continuation-conditionals}

The backward chainer is modified to take in inputs a \emph{control
structure}, a \emph{context}, in addition to a control theory and a
query.  A continuation conditional is placed at the entry of the base
case call, invoking \texttt{\$bcont} in order to determine whether to
continue or to prune the current branch.  Another conditional is
placed at the exit of the match query, invoking \texttt{\$mcont} to
determine whether to continue or to prune the current branch.  It is
important to have a conditional at the exit of the match query because
at that point more information is available to the continuation
predicate.  The built-in function \texttt{empty} is used to prune the
current branch.  The modified base case can be found below and more
information (including the modified recursive step) can be found
here~\cite{TODO}.  \small{
\begin{minted}{scheme}
;; Modified base case
(= (bc $kb                                               ; Knowledge base
       (MkControl $absupd $argupd $bcont $rcont $mcont)  ; Control
       $ctx                                              ; Context
       (: $prf $thrm))                                   ; Query
   ;; Base case continuation conditional
   (if ($bcont (: $prf $thrm) $ctx)
       ;; Continue by querying the kb
       (match $kb (: $prf $thrm)
              ;; Match continuation conditional
              (if ($mcont (: $prf $thrm) $ctx)
                  ;; Continue by returning the queried result
                  (: $prf $thrm)
                  ;; Terminate by pruning
                  (empty)))
       ;; Terminate by pruning
       (empty)))
\end{minted}
}

%------------------------------------------------------------------------------
\end{document}
